Ext.define('X.controller.mixin.User', {
//    This sets a variable on X that stores reference to the authenticated user for easy access
//    Note that we are using X.authenticatedEntity for now; the plan is to retire that variable and use
//    X.authenticatedUser exclusively
    setReferencesOnXToGivenAuthenticatedUser: function(authenticatedUser) {
        X.authenticatedUser = authenticatedUser;
//        TODO: Retire authenticatedEntity and use only authenticatedUser
        X.authenticatedEntity = authenticatedUser;
    },
//    Does opposite of what this.setReferencesOnXToGivenAuthenticatedUser() does
    resetReferencesOnXToGivenAuthenticatedUser: function(authenticatedUser) {
        X.authenticatedUser = null;
//        TODO: Retire authenticatedEntity and use only authenticatedUser
        X.authenticatedEntity = null;
    },
//    This expects:
//    {
//      user: <Object>
//    }
//    This: 
//      1. sets session: calls setSession()
//      2. sets authenticated user: calls setAuthenticatedUser()
    logUserIn: function(options) {
        var me = this;
        if (me.getDebug()) {
            console.log('Debug: X.controller.mixin.User.logUserIn(): Options:');
            console.log(options);
            console.log('Debug: Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
        }
        
        options = (Ext.isObject(options) && !Ext.isEmpty(options)) ? options : false;
        if(Ext.isObject(options)) {
            var user = ('user' in options && Ext.isObject(options.user) && !Ext.isEmpty(options.user)) ? options.user : false;
            if(Ext.isObject(user)) {
                var unSyncedAuthenticatedUser = Ext.create('X.model.AuthenticatedUser', user);
                if(Ext.isObject(unSyncedAuthenticatedUser) && 'isValid' in unSyncedAuthenticatedUser && unSyncedAuthenticatedUser.isValid()) {
                    return me.setSession({
                        user: unSyncedAuthenticatedUser
                    }) && me.setAuthenticatedUser({
                        user: unSyncedAuthenticatedUser
                    });
                }
            }
        }
        
        return false;
    },
//    A user is never logged out of Parse, meaning that the session key generated by Parse for any user
//    lives forever. So, logging out means that any subsequent request to Parse's REST API should
//    not contain the session key header, the authenticated user store's url should not have any user id
//    as a postfix to its endpoint,  the authenticated user store must be emptied, and the 
//    parse session localstorage store must be emptied
    logUserOut: function() {
        var me = this;
        if (me.getDebug()) {
            console.log('Debug: X.controller.mixin.User.logUserIn(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
        }
        
        me.resetReferencesOnXToGivenAuthenticatedUser();
        var authenticatedUserStore = Ext.getStore('AuthenticatedUserStore');
        if (Ext.isObject(authenticatedUserStore)) {
            authenticatedUserStore.reset();
        }
        var parseSessionStore = Ext.getStore('ParseSessionStore');
        if (Ext.isObject(parseSessionStore) && parseSessionStore.getAllCount() > 0) {
            parseSessionStore.removeAll();
            parseSessionStore.sync();
        }
        
        return me;
    },
    
//    This expects:
//    {
//      user: <'AuthenticatedUser' model instance>
//    }
//    Updates session localstorage
    setSession: function(options) {
        var me = this;
        if (me.getDebug()) {
            console.log('Debug: X.controller.mixin.User.setSession(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
        }
        
        options = (Ext.isObject(options) && !Ext.isEmpty(options)) ? options : false;
        if (Ext.isObject(options)) {
            var user = ('user' in options && Ext.isObject(options.user) && !Ext.isEmpty(options.user)) ? options.user : false;
            if (Ext.isObject(user)) {
                var objectId = user.get('objectId'),
                        userId = (Ext.isString(objectId) && !Ext.isEmpty(objectId)) ? objectId : false;
                if (userId) {
                    var sessionToken = user.get('sessionToken');
                    sessionToken = (Ext.isString(sessionToken) && !Ext.isEmpty(sessionToken)) ? sessionToken : false;
                    if (sessionToken) {
                        var parseSessionStore = Ext.getStore('ParseSessionStore');
                        if (Ext.isObject(parseSessionStore)) {
                            parseSessionStore.setSession({
                                userId: userId,
                                sessionToken: sessionToken
                            });
                            
                            return me;
                        }
                    }
                }
            }
        }
        
        return false;
    },
    
//    This expects:
//    {
//      user: <'AuthenticatedUser' model instance>
//    }
//    This: 
//      1. locally updates authenticated user store
//      2. sets variables on X that denote authenticated user
    setAuthenticatedUser: function(options) {
        var me = this;
        if (me.getDebug()) {
            console.log('Debug: X.controller.mixin.User.setAuthenticatedUser(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
        }
        
        options = (Ext.isObject(options) && !Ext.isEmpty(options)) ? options : false;
        if(Ext.isObject(options)) {
            var user = ('user' in options && Ext.isObject(options.user) && !Ext.isEmpty(options.user)) ? options.user : false;
            if(Ext.isObject(user) && !Ext.isEmpty(user)) {
                var authenticatedUserStore = Ext.getStore('AuthenticatedUserStore');
                if(Ext.isObject(authenticatedUserStore)) {
                    if (authenticatedUserStore.locallySetGivenUserAsAuthenticatedUser({
                        user: user
                    })) {
                        me.setReferencesOnXToGivenAuthenticatedUser(user);

                        return me;
                    }
                }
            }
        }
        
        return false;
    },
    
//    This uses this.checkIfAuthenticatedUserExists() and this.loadAuthenticatedUserStoreFromSession() to perform the logic
    checkLoginAndResumeIfNotExistsOrRedirectIfExists: function(action) {
        var me = this;
        me.checkIfAuthenticatedUserExists({
            // Callback if authenticated user exists
            fn: function() {
                if (me.getUrlHash() !== X.XConfig.getDEFAULT_USER_PAGE()) {
                    if (me.getDebug()) {
                        console.log('Debug: X.controller.mixin.User.checkLoginAndResumeIfNotExistsOrRedirectIfExists(): Authenticated user exists. Current URL hash - ' + me.getUrlHash() + '. Will redirect to X.XConfig.getDEFAULT_USER_PAGE() = ' + X.XConfig.getDEFAULT_USER_PAGE() + ': Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                    }
                    me.redirectTo(X.XConfig.getDEFAULT_USER_PAGE());
                }
            },
            scope: me
        },
        {
            // Callback if authenticated user does not exist
            fn: function() {
                me.loadAuthenticatedUserStoreFromSession({
                    // Callback if authenticated user exists
                    fn: function() {
                        if (me.getUrlHash() !== X.XConfig.getDEFAULT_USER_PAGE()) {
                            if (me.getDebug()) {
                                console.log('Debug: X.controller.mixin.User.checkLoginAndResumeIfExistsOrRedirectIfNotExists(): Authenticated user exists. Current URL hash - ' + me.getUrlHash() + '. Will redirect to X.XConfig.getDEFAULT_USER_PAGE() = ' + X.XConfig.getDEFAULT_USER_PAGE() + ': Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                            }
                            me.redirectTo(X.XConfig.getDEFAULT_USER_PAGE());
                        }
                    },
                    scope: me
                },
                {
                    // Callback if authenticated user does not exist
                    fn: function() {
                        if (me.getDebug()) {
                            console.log('Debug: X.controller.mixin.User.checkLoginAndResumeIfNotExistsOrRedirectIfExists(): Authenticated user does not exist. Will do action.resume(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                        }
                        action.resume();
                    },
                    scope: me
                });
            },
            scope: me
        });
    },
//    This uses this.checkIfAuthenticatedUserExists() and this.loadAuthenticatedUserStoreFromSession() to perform the logic
    checkLoginAndResumeIfExistsOrRedirectIfNotExists: function(action) {
        var me = this;
        
        me.checkIfAuthenticatedUserExists({
            // Callback if authenticated user exists
            fn: function() {
                if (me.getDebug()) {
                    console.log('Debug: X.controller.mixin.User.checkLoginAndResumeIfExistsOrRedirectIfNotExists(): Authenticated user exists. Will do action.resume(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                }
                action.resume();
            },
            scope: me
        },
        {
            // Callback if authenticated user does not exist
            fn: function() {
                me.loadAuthenticatedUserStoreFromSession({
                    // Callback if authenticated user exists
                    fn: function() {
                        if (me.getDebug()) {
                            console.log('Debug: X.controller.mixin.User.checkLoginAndResumeIfExistsOrRedirectIfNotExists(): Authenticated user exists. Will do action.resume(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                        }
                        action.resume();
                    },
                    scope: me
                },
                {
                    // Callback if authenticated user does not exist
                    fn: function() {
                        if (me.getUrlHash() !== X.XConfig.getDEFAULT_LOGIN_PAGE()) {
                            if (me.getDebug()) {
                                console.log('Debug: X.controller.mixin.User.checkLoginAndResumeIfExistsOrRedirectIfNotExists(): Authenticated user does not exist. Current URL hash - ' + me.getUrlHash() + '. Will redirect to X.XConfig.getDEFAULT_LOGIN_PAGE() = ' + X.XConfig.getDEFAULT_LOGIN_PAGE() + ': Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                            }
                            me.redirectTo(X.XConfig.getDEFAULT_LOGIN_PAGE());
                        }
                    },
                    scope: me
                });
            },
            scope: me
        });
        
        return me;
    },
//    This checks X.authenticatedUser to verify whether an authenticated user exists
    checkIfAuthenticatedUserExists: function(existsCallback, doesNotExistCallback) {
        var me = this;
        if (Ext.isObject(X.authenticatedUser)) {
            me.executeCallback(existsCallback);
            return true;
        }
        else {
            me.executeCallback(doesNotExistCallback);
            return false;
        }
        return me;
    },
    
//    This loads authenticated user store only if a session is found in local storage,
//    and before it does, it also sets the session header and the url on the store
    loadAuthenticatedUserStoreFromSession: function(existsCallback, doesNotExistCallback) {
        var me = this;
        
        var parseSessionStore = Ext.getStore('ParseSessionStore');
        if (Ext.isObject(parseSessionStore)) {
            var session = parseSessionStore.getSession();
            if (Ext.isObject(session) && !Ext.isEmpty(session)) {
                
//                Proceed with loading the store only if a session is found in local storage
                me.loadAuthenticatedUserStore(existsCallback, doesNotExistCallback);
                
//                Return true/me only if the session store has a user in session i.e. a session token exists
                return me;
            }
        }
        
//        Don't proceed with the load if a session does not exist in local storage
//        Ideally, when a session in local storage is not found, 
//        redirect user to the login form
        me.executeCallback(doesNotExistCallback);
        
//        Return true/me only if the session store has a user in session i.e. a session token exists
        return false;
    },
    
//    Use this method to load the Authenticated User store; avoid loading
//    the store directly from outside using store.load(). Use this wrapper
//    instead
//    
//    Event handler 'onBeforeLoad' on the store will make sure that
//    the session header and url endpoint get set up correctly
    loadAuthenticatedUserStore: function(existsCallback, doesNotExistCallback) {
        var me = this;
        
        var authenticatedUserStore = Ext.getStore('AuthenticatedUserStore');
        if (Ext.isObject(authenticatedUserStore)) {
            authenticatedUserStore.load(function(records, operation, success) {
                if (me.getDebug()) {
                    console.log('Debug: X.controller.mixin.User: loadAuthenticatedUserStore(): Success: ' + success + ': Records received:');
                    console.log(records);
                    console.log('Debug: Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                }
                
                if(success) {
                    if (!Ext.isEmpty(records)) {
//                        This sets up references on X e.g. X.authenticatedUser
                        me.setReferencesOnXToGivenAuthenticatedUser(records[0]);
                        
//                        This loads all groups now that we have the authenticated user
//                        This is a method in the Group mixin
                        me.loadAllGroups();
                        
                        me.executeCallback(existsCallback);
                    }
                    else {
                        me.executeCallback(doesNotExistCallback);
                    }
                }
                else {
                    me.executeCallback(doesNotExistCallback);
                }
            });
        }
        
        return me;
    },
    
//    This assumes that the session header and url endpoint have already been set up correctly
    saveAuthenticatedUser: function(options) {
        var me = this;
        if (me.getDebug()) {
            console.log('Debug: X.controller.mixin.User.saveAuthenticatedUser(): Options:');
            console.log(options);
            console.log('Debug: Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
        }
        
        var authenticatedUser = X.authenticatedUser;
        if (Ext.isObject(authenticatedUser)) {
            var errors = authenticatedUser.validate();
            if (!errors.isValid()) {
                authenticatedUser.reject();
                me.generateUserFailedUpdatedWindow({
                    message: errors.getAt(0).
                            getMessage()
                });
                return false;
            }
            else {
                var silent = (Ext.isObject(options) && Ext.isBoolean(options.silent)) ? options.silent : false;
                
                authenticatedUser.save({
                    success: function(record, operation) {
                        if (me.getDebug()) {
                            console.log('Debug: X.controller.mixin.User.saveAuthenticatedUser(): Success. Received serverResponse:');
                            console.log(operation.getResponse());
                            console.log('Debug: Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                        }
                        
                        me.commitOrRejectModelAndGenerateUserFeedbackOnSavingModel({
                            operation: operation,
                            model: authenticatedUser,
                            silent: silent
                        });
                    },
                    failure: function(record, operation) {
                        if (me.getDebug()) {
                            console.log('Debug: X.controller.mixin.User.saveAuthenticatedUser(): Failed. Received serverResponse:');
                            console.log(operation.getResponse());
                            console.log('Debug: Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                        }
                        
                        var serverResponse = operation.getResponse(),
                                serverResponseText = Ext.decode(serverResponse.responseText),
                                serverResponseError = serverResponseText.error;
                        
                        me.commitOrRejectModelAndGenerateUserFeedbackOnSavingModel({
                            operation: operation,
                            model: authenticatedUser,
                            message: serverResponseError,
                            silent: silent
                        });
                    }
                });
            }
        }
        else {
            return false;
        }
        return me;
    }
});
