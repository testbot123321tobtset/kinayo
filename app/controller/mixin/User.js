Ext.define('X.controller.mixin.User', {
    /*
     * LOGIN
     */
    //    This expects:
    //    {
    //      user: <Object>
    //    }
    //    This is currently used only when:
    //      1. the user signs up for the first time; if the sign up is successful, use
    //         this to log her in automatically
    //      2. the user explicitly logs in via the login form
    //    If a user is already logged in but refreshes the page, then the session gets refreshed
    //    every time the authenticated user store loads 
    //    This: 
    //      1. sets session: calls setSession()
    //      2. sets authenticated user: calls setAuthenticatedUser()
    logUserIn: function(options) {
        var me = this;
        if (me.getDebug()) {
            console.log('Debug: X.controller.mixin.User.logUserIn(): Options:');
            console.log(options);
            console.log('Debug: Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
        }

        options = (Ext.isObject(options) && !Ext.isEmpty(options)) ? options : false;
        if (Ext.isObject(options)) {
            var user = ('user' in options && Ext.isObject(options.user) && !Ext.isEmpty(options.user)) ? options.user : false;
            if (Ext.isObject(user)) {
                var unSyncedAuthenticatedUser = Ext.create('X.model.AuthenticatedUser', user);
                if (Ext.isObject(unSyncedAuthenticatedUser) && 'isValid' in unSyncedAuthenticatedUser && unSyncedAuthenticatedUser.isValid()) {
                    return me.setSession({
                        user: unSyncedAuthenticatedUser
                    }) && me.setAuthenticatedUser({
                        user: unSyncedAuthenticatedUser
                    });
                }
            }
        }

        return false;
    },
    /*
     * LOGOUT
     */
    //    A user is never logged out of Parse, meaning that the session key generated by Parse for any user
    //    lives forever. So, logging out means that any subsequent request to Parse's REST API should
    //    not contain the session key header, the authenticated user store's url should not have any user id
    //    as a postfix to its endpoint,  the authenticated user store must be emptied, and the 
    //    parse session localstorage store must be emptied
    logUserOut: function() {
        var me = this;
        if (me.getDebug()) {
            console.log('Debug: X.controller.mixin.User.logUserIn(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
        }

        me.resetReferencesOnXToGivenAuthenticatedUser();
        var authenticatedUserStore = Ext.getStore('AuthenticatedUserStore');
        if (Ext.isObject(authenticatedUserStore)) {
            authenticatedUserStore.reset();
        }
        var parseSessionStore = Ext.getStore('ParseSessionStore');
        if (Ext.isObject(parseSessionStore) && parseSessionStore.getAllCount() > 0) {
            parseSessionStore.removeAll();
            parseSessionStore.sync();
        }

        return me;
    },
    /*
     * LOAD
     */
    //    This loads authenticated user store only if a session is found in local storage,
    //    and before it does, it also sets the session header and the url on the store
    loadAuthenticatedUserStoreFromSession: function(existsCallback, doesNotExistCallback) {
        var me = this;

        var parseSessionStore = Ext.getStore('ParseSessionStore');
        if (Ext.isObject(parseSessionStore)) {
            var session = parseSessionStore.getSession();
            if (Ext.isObject(session) && !Ext.isEmpty(session)) {

                //                Proceed with loading the store only if a session is found in local storage
                me.loadAuthenticatedUserStore(existsCallback, doesNotExistCallback);

                //                Return true/me only if the session store has a user in session i.e. a session token exists
                return me;
            }
        }

        //        Don't proceed with the load if a session does not exist in local storage
        //        Ideally, when a session in local storage is not found, 
        //        redirect user to the login form
        me.executeCallback(doesNotExistCallback);

        //        Return true/me only if the session store has a user in session i.e. a session token exists
        return false;
    },
    //    Use this method to load the Authenticated User store; avoid loading
    //    the store directly from outside using store.load(). Use this wrapper
    //    instead
    //    
    //    Event handler 'onBeforeLoad' on the store will make sure that
    //    the session header and url endpoint get set up correctly
    //    Event handler 'onLoad' on the store will make sure that that all
    //    groups stores are automatically updated
    loadAuthenticatedUserStore: function(existsCallback, doesNotExistCallback) {
        var me = this;

        var authenticatedUserStore = Ext.getStore('AuthenticatedUserStore');
        if (Ext.isObject(authenticatedUserStore)) {
            authenticatedUserStore.load(function(records, operation, success) {
                if (me.getDebug()) {
                    console.log('Debug: X.controller.mixin.User: loadAuthenticatedUserStore(): Success: ' + success + ': Records received:');
                    console.log(records);
                    console.log('Debug: Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                }

                if (success) {
                    if (!Ext.isEmpty(records)) {
                        //                        This sets up references on X e.g. X.authenticatedUser
                        me.setReferencesOnXToGivenAuthenticatedUser(records[0]);

                        me.executeCallback(existsCallback);
                    }
                    else {
                        me.executeCallback(doesNotExistCallback);
                    }
                }
                else {
                    me.executeCallback(doesNotExistCallback);
                }
            });
        }

        return me;
    },
    /*
     * SAVE
     */
    saveAuthenticatedUser: function(options) {
        var me = this;
        if (me.getDebug()) {
            console.log('Debug: X.controller.mixin.User.saveAuthenticatedUser(): Options:');
            console.log(options);
            console.log('Debug: Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
        }

        var authenticatedUser = X.authenticatedUser;
        if (Ext.isObject(authenticatedUser)) {
            var typeOfSave = ('typeOfSave' in options && Ext.isString(options.typeOfSave) && !Ext.isEmpty(options.typeOfSave)) ? options.typeOfSave : 'edit';

            var hasBeenValidated = ('validated' in options && Ext.isBoolean(options.validated)) ? options.validated : false;
            if (typeOfSave !== 'destroy' && !hasBeenValidated) {
                var errors = authenticatedUser.validate();
                if (!errors.isValid()) {
                    authenticatedUser.reject();
                    me.generateUserFailedUpdatedWindow({
                        message: errors.getAt(0).
                                getMessage()
                    });
                    return false;
                }
            }

            var silent = ('silent' in options && Ext.isBoolean(options.silent)) ? options.silent : false;
            var optionsToSaveOperation = {
                success: function(record, operation) {
                    if (me.getDebug()) {
                        console.log('Debug: X.controller.mixin.User.saveAuthenticatedUser(): Success. Received serverResponse:');
                        console.log(operation.getResponse());
                        console.log('Debug: Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                    }

                    me.commitOrRejectModelAndGenerateUserFeedbackOnSavingModel({
                        operation: operation,
                        model: authenticatedUser,
                        silent: silent
                    });
                },
                failure: function(record, operation) {
                    if (me.getDebug()) {
                        console.log('Debug: X.controller.mixin.User.saveAuthenticatedUser(): Failed. Received serverResponse:');
                        console.log(operation.getResponse());
                        console.log('Debug: Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                    }

                    me.commitOrRejectModelAndGenerateUserFeedbackOnSavingModel({
                        operation: operation,
                        model: authenticatedUser,
                        silent: silent
                    });
                }
            };

            switch (typeOfSave) {
                case 'edit':
                    if (me.getDebug()) {
                        console.log('Debug: X.controller.mixin.User.saveAuthenticatedUser(): Will call save(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                    }
                    authenticatedUser.save(optionsToSaveOperation);
                    break;
                case 'destroy':
                    if (me.getDebug()) {
                        console.log('Debug: X.controller.mixin.User.saveAuthenticatedUser(): Will call erase(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                    }
                    authenticatedUser.erase(optionsToSaveOperation);
                    break;
                default:
                    break;
            }
        }
    },
    /*
     * HELPERS
     */
    //    This sets a variable on X that stores reference to the authenticated user for easy access
    //    Note that we are using X.authenticatedEntity for now; the plan is to retire that variable and use
    //    X.authenticatedUser exclusively
    setReferencesOnXToGivenAuthenticatedUser: function(authenticatedUser) {
        X.authenticatedUser = authenticatedUser;
        //        TODO: Retire authenticatedEntity and use only authenticatedUser
        X.authenticatedEntity = authenticatedUser;
    },
    //    Does opposite of what this.setReferencesOnXToGivenAuthenticatedUser() does
    resetReferencesOnXToGivenAuthenticatedUser: function() {
        X.authenticatedUser = null;
        //        TODO: Retire authenticatedEntity and use only authenticatedUser
        X.authenticatedEntity = null;
    },
    //    This expects:
    //    {
    //      user: <'AuthenticatedUser' model instance>
    //    }
    //    Updates session localstorage
    setSession: function(options) {
        var me = this;
        if (me.getDebug()) {
            console.log('Debug: X.controller.mixin.User.setSession(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
        }

        options = (Ext.isObject(options) && !Ext.isEmpty(options)) ? options : false;
        if (Ext.isObject(options)) {
            var user = ('user' in options && Ext.isObject(options.user) && !Ext.isEmpty(options.user)) ? options.user : false;
            if (Ext.isObject(user)) {
                var objectId = user.get('objectId'),
                        userId = (Ext.isString(objectId) && !Ext.isEmpty(objectId)) ? objectId : false;
                if (userId) {
                    var sessionToken = user.get('sessionToken');
                    sessionToken = (Ext.isString(sessionToken) && !Ext.isEmpty(sessionToken)) ? sessionToken : false;
                    if (sessionToken) {
                        var parseSessionStore = Ext.getStore('ParseSessionStore');
                        if (Ext.isObject(parseSessionStore)) {
                            parseSessionStore.setSession({
                                userId: userId,
                                sessionToken: sessionToken
                            });

                            return me;
                        }
                    }
                }
            }
        }

        return false;
    },
    //    This expects:
    //    {
    //      user: <'AuthenticatedUser' model instance>
    //    }
    //    This: 
    //      1. locally updates authenticated user store
    //      2. sets variables on X that denote authenticated user
    setAuthenticatedUser: function(options) {
        var me = this;
        if (me.getDebug()) {
            console.log('Debug: X.controller.mixin.User.setAuthenticatedUser(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
        }

        options = (Ext.isObject(options) && !Ext.isEmpty(options)) ? options : false;
        if (Ext.isObject(options)) {
            var user = ('user' in options && Ext.isObject(options.user) && !Ext.isEmpty(options.user)) ? options.user : false;
            if (Ext.isObject(user) && !Ext.isEmpty(user)) {
                var authenticatedUserStore = Ext.getStore('AuthenticatedUserStore');
                if (Ext.isObject(authenticatedUserStore)) {
                    if (me.locallySetGivenUserAsAuthenticatedUser({
                        user: user
                    })) {
                        me.setReferencesOnXToGivenAuthenticatedUser(user);

                        return me;
                    }
                }
            }
        }

        return false;
    },
    //    This sets a given user as the authenticated user in the authenticated user store
    //    This means that it'll replace any record in this store with the given user and
    //    edit the session header and the url approporiately â€“ all without having to sync
    //    back to the server
    locallySetGivenUserAsAuthenticatedUser: function(options) {
        var me = this;
        if (X.config.Config.getDEBUG()) {
            console.log('Debug: X.controller.mixin.User.locallySetGivenUserAsAuthenticatedUser(): Options:');
            console.log(options);
            console.log('Debug: Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
        }
        options = (Ext.isObject(options) && !Ext.isEmpty(options)) ? options : false;
        if (options) {
            var user = ('user' in options && Ext.isObject(options.user) && !Ext.isEmpty(options.user)) ? options.user : false;
            if (user) {
                var authenticatedUserStore = Ext.getStore('AuthenticatedUserStore');
                if(Ext.isObject(authenticatedUserStore)) {
                    authenticatedUserStore.each(function(thisUser) {
                        thisUser.destroy();
                        thisUser.commit();
                    });
                    authenticatedUserStore.add(user);
                    user.commit();

                    authenticatedUserStore.setSessionHeaderForAllStores(user.get('sessionToken'));
                    authenticatedUserStore.setUrlPostfixEndpoint(user.get('objectId'));

                    return me;
                }
            }
        }

        return false;
    },
    //    This uses this.checkIfAuthenticatedUserExists() and this.loadAuthenticatedUserStoreFromSession() to perform the logic
    checkLoginAndResumeIfNotExistsOrRedirectIfExists: function(action) {
        var me = this;
        me.checkIfAuthenticatedUserExists({
            // Callback if authenticated user exists
            fn: function() {
                if (me.getUrlHash() !== X.XConfig.getDEFAULT_USER_PAGE()) {
                    if (me.getDebug()) {
                        console.log('Debug: X.controller.mixin.User.checkLoginAndResumeIfNotExistsOrRedirectIfExists(): Authenticated user exists. Current URL hash - ' + me.getUrlHash() + '. Will redirect to X.XConfig.getDEFAULT_USER_PAGE() = ' + X.XConfig.getDEFAULT_USER_PAGE() + ': Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                    }
                    me.redirectTo(X.XConfig.getDEFAULT_USER_PAGE());
                }
            },
            scope: me
        },
        {
            // Callback if authenticated user does not exist
            fn: function() {
                me.loadAuthenticatedUserStoreFromSession({
                    // Callback if authenticated user exists
                    fn: function() {
                        if (me.getUrlHash() !== X.XConfig.getDEFAULT_USER_PAGE()) {
                            if (me.getDebug()) {
                                console.log('Debug: X.controller.mixin.User.checkLoginAndResumeIfExistsOrRedirectIfNotExists(): Authenticated user exists. Current URL hash - ' + me.getUrlHash() + '. Will redirect to X.XConfig.getDEFAULT_USER_PAGE() = ' + X.XConfig.getDEFAULT_USER_PAGE() + ': Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                            }
                            me.redirectTo(X.XConfig.getDEFAULT_USER_PAGE());
                        }
                    },
                    scope: me
                },
                {
                    // Callback if authenticated user does not exist
                    fn: function() {
                        if (me.getDebug()) {
                            console.log('Debug: X.controller.mixin.User.checkLoginAndResumeIfNotExistsOrRedirectIfExists(): Authenticated user does not exist. Will do action.resume(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                        }
                        action.resume();
                    },
                    scope: me
                });
            },
            scope: me
        });
    },
    //    This uses this.checkIfAuthenticatedUserExists() and this.loadAuthenticatedUserStoreFromSession() to perform the logic
    checkLoginAndResumeIfExistsOrRedirectIfNotExists: function(action) {
        var me = this;

        me.checkIfAuthenticatedUserExists({
            // Callback if authenticated user exists
            fn: function() {
                if (me.getDebug()) {
                    console.log('Debug: X.controller.mixin.User.checkLoginAndResumeIfExistsOrRedirectIfNotExists(): Authenticated user exists. Will do action.resume(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                }
                action.resume();
            },
            scope: me
        },
        {
            // Callback if authenticated user does not exist
            fn: function() {
                me.loadAuthenticatedUserStoreFromSession({
                    // Callback if authenticated user exists
                    fn: function() {
                        if (me.getDebug()) {
                            console.log('Debug: X.controller.mixin.User.checkLoginAndResumeIfExistsOrRedirectIfNotExists(): Authenticated user exists. Will do action.resume(): Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                        }
                        action.resume();
                    },
                    scope: me
                },
                {
                    // Callback if authenticated user does not exist
                    fn: function() {
                        if (me.getUrlHash() !== X.XConfig.getDEFAULT_LOGIN_PAGE()) {
                            if (me.getDebug()) {
                                console.log('Debug: X.controller.mixin.User.checkLoginAndResumeIfExistsOrRedirectIfNotExists(): Authenticated user does not exist. Current URL hash - ' + me.getUrlHash() + '. Will redirect to X.XConfig.getDEFAULT_LOGIN_PAGE() = ' + X.XConfig.getDEFAULT_LOGIN_PAGE() + ': Timestamp: ' + Ext.Date.format(new Date(), 'H:i:s'));
                            }
                            me.redirectTo(X.XConfig.getDEFAULT_LOGIN_PAGE());
                        }
                    },
                    scope: me
                });
            },
            scope: me
        });

        return me;
    },
    //    This checks X.authenticatedUser to verify whether an authenticated user exists
    checkIfAuthenticatedUserExists: function(existsCallback, doesNotExistCallback) {
        var me = this;
        if (Ext.isObject(X.authenticatedUser)) {
            me.executeCallback(existsCallback);
            return true;
        }
        else {
            me.executeCallback(doesNotExistCallback);
            return false;
        }
        return me;
    }
});
